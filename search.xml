<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LruCache缓存图片研究小结]]></title>
    <url>%2F2018%2F12%2F20%2FLruCache%E7%BC%93%E5%AD%98%E5%9B%BE%E7%89%87%E7%A0%94%E7%A9%B6%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言 上一篇研究了LinkedHashMap实现LRU策略，虽然通过上述方式来实现图片缓存可以优化内存的使用效率，但是这种方式也存在一些问题，例如，LinkedHashMap不是线程安全的，所以在操作时需要考虑线程安全问题。另外在缓存时，只能指定缓存数据条目的数量，不能指定缓存区的大小，如果需要缓存的图片都比较大，可能就会出现问题。 其实在Android SDK 中已经为我们提供了一个实现LRU策略的cache类，LruCache类，这个类封装了LinkedHashMap并且解决了LinkedHashMap中存在的问题，今天我们以LruCache缓存图片为例研究下这个类。 LruCache 有一点需要提前说明下，今天我们研究的是android.support.v4.util包中的LruCache类而不是android.util包中也有一个LruCache类，这点需要提前说明下，不然很容易蒙圈，因为这两个类中有些方法实现是不同的。 首先我们看一下LruCache的成员变量，代码如下 12345678910private final LinkedHashMap&lt;K, V&gt; map; private int size;//当前容量private int maxSize;//最大容量private int putCount;//put的次数 private int createCount;//create的次数 private int evictionCount;//回收次数private int hitCount;//命中次数private int missCount;//丢失的次数 再看下构造方法。 1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; 在构造方法中初始化了maxSize和LinkedHashMap，并且LinkedHashMap为按照访问顺序排序（此部分请参照上一篇文章）。maxSize即为最大容量。 前面提到LruCache可以指定缓存区大小，这怎么实现呢？其实，实现起来很简单只要在初始化的时候重写LruCache提供的sizeOf方法即可，代码如下。 12345678910int LRU_CACHE_SIZE = 4 * 1024 * 1024; //4MBLruCache&lt;String,Bitmap&gt; lruCache=new LruCache&lt;String,Bitmap&gt;(LRU_CACHE_SIZE) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; if (value != null) return value.getByteCount(); else return 0; &#125;&#125;; 首先我们定义了LruCache的最大容量为4 * 1024 * 1024，即4M的空间，然后我们重写sizeOf方法，让这个方法返回Bitmap的字节数。为什么这样写就可以指定缓存区大大小呢？接下来我们看下比较重要的put和get方法，你就会明白了~ 首先看下put方法的源码。 12345678910111213141516171819202122 public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; synchronized (this) &#123; putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; trimToSize(maxSize); return previous;&#125; 在方法体中，我们发现当key或者value为空时会抛出异常，这部分和LinkedHashMap是不同的，说明LruCache类是不支持key或者value为空，并且在对map进行put操作时加了synchronized ，保证了线程安全。另外我们发现有如下操作 1size += safeSizeOf(key, value); 这部分看上去像对size（当前容量）的累加，我们继续进入到safeSizeOf方法中 1234567private int safeSizeOf(K key, V value) &#123; int result = sizeOf(key, value); if (result &lt; 0) &#123; throw new IllegalStateException("Negative size: " + key + "=" + value); &#125; return result;&#125; 在这个方法中看到了之前重写sizeOf方法，看到这里我想大家就明白了。**我们之前重写sizeOf方法让它返回bitmap的字节数，而在put方法中会对每次put进来的bimap的字节数利用size进行累加，这样我们利用size和maxSize进行比较，就可以得知当前容量是否大于最大容量，当大于时就可以进行删除最近最少少用的资源的操作了。**另外sizeOf默认情况下是返回1的，所以如果不重写sizeOf方法，LruCache也是进行“计数”的。 接着看put方法的代码，我们会发现如下操作。 1234previous = map.put(key, value);if (previous != null) &#123; size -= safeSizeOf(key, previous);&#125; 我们都知道，在对一个hashmap进行put操作的时候 ，如果put的key-value键值对中的key已经存在与map中，新put的value会覆盖旧value，并且会返回旧value。如果key不存在于map中，则会返回null。这里利用previous获取返回值，如果previous不为空，则当前容量会减去previous的大小，这部分比较好理解，其实就是防止同一个key对应新旧value的大小的重复叠加。 接着往下看，在previous不为空的时候，会调用 entryRemoved(false, key, previous, value) 方法，并且把previous传进去了，查看此方法，我们发现此方法并没有函数体，看来需要我们重写此方法。 1protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) 根据前面所讲，我们可以在初始化的时候重写这个方法，来释放掉一个key对应的旧value所占用的资源，代码如下 12345678910111213141516LruCache&lt;String,Bitmap&gt; lruCache=new LruCache&lt;String,Bitmap&gt;(LRU_CACHE_SIZE) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; if (value != null) return value.getByteCount(); else return 0; &#125; @Override protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) &#123; if(evicted==false&amp;&amp;oldValue！=null)&#123; oldValue.recycle();//释放bitmap资源 &#125; &#125;&#125;; 看到这里，可能会有疑问，在什么方法里会进行删除最近最少的操作呢？接着看put方法我们会发现trimToSize方法，答案其实就在这个方法里面。代码如下 12345678910111213141516171819202122232425public void trimToSize(int maxSize) &#123; while (true) &#123;//不断循环删除linkedHashMap首元素，也就是最近最少访问的条目，直到size小于最大容量或者map中已经没有数据 K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; if (size &lt;= maxSize || map.isEmpty()) &#123;//直到当前容量小于最大容量 break; &#125; Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();//指向首元素 key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key);//删除最近最少的entry size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125;&#125; 观察方法体我们发现，当当前容量大于最大容量时，会不断删除首元素即最近最少访问的元素，然后重新计算当前容量大小。只有在当前容量小于最大容量或者map中没有数据的时候才会break出去。在代码的最后也会调用一次entryRemoved(true, key, value, null)方法，并且把因为空间不足而删除的元素的key和value传递进去，不过第一参数为true有别与先前调用时传递的false，所以根据第一参数区别我们就可以进行一些不一样的操作。 1234567protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) &#123; if(evicted==false&amp;&amp;oldValue!=null)&#123; oldValue.recycle(); &#125;if(evicted==true&amp;&amp;oldValue!=null)&#123; //TODO 根据key value 进行二级缓存 &#125;&#125; 好了，put方法说明的比较详细，相信大家已经有了比较深的了解，接下来get方法我们加快点节奏。get方法源码如下 123456789101112131415161718192021222324252627282930313233343536373839public final V get(K key) &#123; if (key == null) &#123;//key 不允许为空 throw new NullPointerException("key == null"); &#125; V mapValue; synchronized (this) &#123; mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125; V createdValue = create(key);//根据key进行新建 if (createdValue == null) &#123; return null; &#125; synchronized (this) &#123; createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) &#123;//有返回值，说明key对应value已存在，需要进行重现赋值，即取消上一步操作 map.put(key, mapValue); &#125; else &#123; size += safeSizeOf(key, createdValue); &#125; &#125; if (mapValue != null) &#123; entryRemoved(false, key, createdValue, mapValue);//可以释放刚创建的createdValue return mapValue; &#125; else &#123; trimToSize(maxSize); return createdValue;&#125;&#125; 观察代码，我们发现其实lrucache方法中主要是对linkedhashmap进行get操作，这部分不清除的同学可以看下上一篇关于linkedhashmap的研究总结。我们重点研究下通过key获取到的value为空时的case。观察代码，如果如果出现上述情况，会新建一个createdValue,并且把createdValue put到map中，利用mapValue 获取put返回值，继续判断mapValue 是否为空，如果mapValue 不为空说明此时此key在map中存在对应的value,所以接下来需要进行重新赋值，让key对应的value为mapValue 而不是createdValue。如果mapValue为空，说明key对应的value确实为空，需要进行就是重新计算当前size的大小。在代码的最后会判断mapValue是否为空，如果mapValue不为空的时候，会调用entryRemoved方法，并把createdValue放在oldvalue的位置，因为此时createdValue所占的资源是无用的，所以我们可以在entryRemoved中释放createdValue。如果mapValue不为空又会进入到trimToSize方法中进行容量计算和删除“最近最少”。 好了，get也方法讲完了，最后看下remove方法。 12345678910111213141516171819public final V remove(K key) &#123; if (key == null) &#123; throw new NullPointerException("key == null"); &#125; V previous; synchronized (this) &#123; previous = map.remove(key); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, null); &#125; return previous;&#125; 观察代码，基本上和get和put有异曲同工之妙，在这里就不重复阐述了。 总结 比较重要的方法都讲完了，到此大家对lrucache应该有了一个全面的了解了吧~~接下来我们稍微总结下lrucache吧！ LruCache封装了LinkedHashMap，提供了LRU缓存的功能，并且在关键操作加了synchronized ，实现了线程安全。 LruCache提供了trimToSize方法，当容量不足时会自动删除最近最少访问的键值对。 LruCache提供了entryRemoved(boolean evicted, K key, V oldValue, V newValue)方法,通过重写这个方，结合put,get,remove方法我们可以做更多的事情。 LruCache不允许空键值； LruCache提供了sizeof方法，重写这个方法可以实现指定缓存区大小，而不是像LinkedHashMap一样只能指定缓存条目数。]]></content>
      <categories>
        <category>安卓笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[通过LinkedHashMap缓存图片并实现LRU策略]]></title>
    <url>%2F2018%2F12%2F20%2F%E9%80%9A%E8%BF%87LinkedHashMap%E7%BC%93%E5%AD%98%E5%9B%BE%E7%89%87%E5%B9%B6%E5%AE%9E%E7%8E%B0LRU%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[前言 在Android开发过程中，实现图片缓存是一个很重要的问题，如果处理不当很容易引起OOM等问题。很多图片加载框架中都会使用LRU机制来优化内存使用率。今天我们就看下通过LinkedHashMap如何实现LRU机制。 LRU（Least Recently Used）策略,即当内存使用不足时，把最近最少使用的数据从缓存中移除，保留使用最频繁的数据。 LinkedHashMap LinkedHashMap，它继承与HashMap，底层使用哈希表与双向链表来保存所有元素，上图即为一个双向链表。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。在初始化一个LinkedHashMap时可以指定accessOrder值来指定链表的排序策略，当accessOrder为false的时候链表按插入顺序排序，默认为false，当为true的时候按访问顺序排序，什么是按访问顺序排序呢？ 12345public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); init(); this.accessOrder = accessOrder;&#125; 其实按访问顺序排序就是指在调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。这部分源码如下 1234567891011121314151617181920212223public V get(Object key) &#123; if (key == null) &#123; HashMapEntry&lt;K, V&gt; e = entryForNullKey; if (e == null) return null; if (accessOrder) makeTail((LinkedEntry&lt;K, V&gt;) e); return e.value; &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; for (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - 1)]; e != null; e = e.next) &#123; K eKey = e.key; if (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123; if (accessOrder) makeTail((LinkedEntry&lt;K, V&gt;) e); return e.value; &#125; &#125; return null;&#125; 查看源码我们发现，不管keys是否为空，在accessOrder为true（即按访问顺序排序）后，会先执行makeTail方法，然后再返回元素的Value。我们继续跟到makeTail方法中。 12345678910111213private void makeTail(LinkedEntry&lt;K, V&gt; e) &#123; // Unlink e e.prv.nxt = e.nxt; e.nxt.prv = e.prv; // Relink e as tail LinkedEntry&lt;K, V&gt; header = this.header; LinkedEntry&lt;K, V&gt; oldTail = header.prv; e.nxt = header; e.prv = oldTail; oldTail.nxt = header.prv = e; modCount++;&#125; 观察makeTail的函数体，我们很容易发现这是一个对双向链表中一个元素解绑后与header关联的代码，经过操作后，当前元素会被插入到链表尾部。看到这里，我想大家就明白了为什么通过get方法会使链表按照按访问顺序排序。那当我们put数据的时候又会发生什么呢？通过源码我们发现，当我们put数据的时候，会先执行hashmap的put方法中，这是因为LinkedHashMap并没用重写这个方法而是重写了put方法中所调用的addNewEntry和addNewEntryForNullKey等方法。我们主要看下addNewEntry的函数体。 12345678910111213@Override void addNewEntry(K key, V value, int hash, int index) &#123; LinkedEntry&lt;K, V&gt; header = this.header; LinkedEntry&lt;K, V&gt; eldest = header.nxt; if (eldest != header &amp;&amp; removeEldestEntry(eldest)) &#123; remove(eldest.key); &#125; LinkedEntry&lt;K, V&gt; oldTail = header.prv; LinkedEntry&lt;K, V&gt; newTail = new LinkedEntry&lt;K,V&gt;( key, value, hash, table[index], header, oldTail); table[index] = oldTail.nxt = header.prv = newTail;&#125; addNewEntry方法中首先会获取头指针的下一个元素，并定义为eldest,从字面上理解应该是最老的元素，结合前面get方法的介绍也比较好理解为什么头指针下一个元素会是”最老的“。if中的第一个链表非空的判断比较好理解，然后我们看下removeEldestEntry这个方法 123protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return false;&#125; 默认倩况下返回false的，那什么时候返回true，只有在removeEldestEntry也返回true的时候才会去执行删除“最老”的元素的操作，这样才比较符合我们的逻辑。其实目前LRU策略少一个判断，就是什么时候去执行删除最近最少操作的数据，重新看下LRU的概念，当内存不足时进行删除，而这个内存对LinkedHashMap来说其实就是大小，所以我们只需要在初始化LinkedHashMap的时候重写这个方法并且做一个判断，如果当前大小已经大于LinkedHashMap的容量就返回true,从而就会删除最近最少的数据，码如下。 1234567891011HashMap&lt;String, Bitmap&gt; hardCache = new LinkedHashMap&lt;String, Bitmap&gt;( 10, 0.75f, true) &#123; @Override protected boolean removeEldestEntry(Entry&lt;String, Bitmap&gt; entry) &#123; if (this.size() &gt; CAPACITY) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;; 到这里LinkedHashMap的LRU策略就实现了。下面我们验证下前面所说的。 示例代码： 1234567891011121314151617HashMap&lt;String, String&gt; map=new LinkedHashMap&lt;String,String&gt;(5, 0.75f, true)&#123; protected boolean removeEldestEntry(java.util.Map.Entry&lt;String,String&gt; eldest) &#123; if(this.size()&gt;5)&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125;; for(int i=0;i&lt;5;i++)&#123; map.put("key"+i,"value"+i);&#125; for(String value:map.values())&#123; System.out.println(value);&#125; 输出输出结果为： 12345value0value1value2value3value4 下面我们get下map中的数据 123456789for(int i=0;i&lt;5;i++)&#123; map.put("key"+i,"value"+i);&#125; map.get("key"+3); for(String value:map.values())&#123; System.out.println(value);&#125; 输出结果为： 12345value0value1value2value4value3 结果和我们上面讲的是一致的。接下来改下代码再测试下 12345678910for(int i=0;i&lt;5;i++)&#123; map.put("key"+i,"value"+i);&#125; map.get("key"+3);map.put("key5","value new add"); for(String value:map.values())&#123; System.out.println(value);&#125; 这段代码是向已经满了的LinkedHashMap中继续添加一个元素，根据前所讲，应该会删除第一个元素，即为key0元素被删除，下面看下结果： 12345value1value2value4value3value new add 结果与我们前面所讲的一致。写到这里大家应该对linkedhashmap实现LRU有了一个全面的了解。利用这个机制在缓存图片的时候大大的优化内存使用率，使内存中保留的数据是经常使用的图片]]></content>
      <categories>
        <category>安卓笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello world!]]></content>
  </entry>
</search>
